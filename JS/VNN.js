const fs = require('fs');
const path = require('path');

class Layer {
    constructor(numNeurons, numInputs, activation = 'sigmoid') {
        this.numNeurons = numNeurons;
        this.numInputs = numInputs;
        this.activation = activation;

        this.weights = this.generateRandomMatrix(this.numNeurons, this.numInputs);
        this.biases = new Array(this.numNeurons).fill(0);

        this.input = new Array(this.numNeurons).fill(0);
        this.z = new Array(this.numNeurons).fill(0);
        this.output = new Array(this.numNeurons).fill(0);
        this.error = new Array(this.numNeurons).fill(0);
        this.delta = new Array(this.numNeurons).fill(0);
    }

    generateRandomMatrix(row, col) {
        return Array.from({ length: row }, () =>
            Array.from({ length: col }, () => Math.random()));
    }

    activate(x) {
        if (this.activation === 'sigmoid') return 1 / (1 + Math.exp(-x));
        if (this.activation === 'relu') return Math.max(0, x);
    }

    activationDerivative(x) {
        if (this.activation === 'sigmoid') return x * (1 - x); // x = sigmoid(x)
        if (this.activation === 'relu') return x > 0 ? 1 : 0;
    }

    forward(input) {
        this.input = [...input];
        for (let i = 0; i < this.numNeurons; i++) {
            this.z[i] = this.biases[i];
            for (let j = 0; j < this.numInputs; j++) {
                this.z[i] += this.weights[i][j] * this.input[j];
            }
            this.output[i] = this.activate(this.z[i]);
        }
        return this.output;
    }

    backward(nextLayer) {
        for (let i = 0; i < this.numNeurons; i++) {
            this.error[i] = 0;
            for (let j = 0; j < nextLayer.numNeurons; j++) {
                this.error[i] += nextLayer.delta[j] * nextLayer.weights[j][i];
            }
            if (this.activation == 'relu')
                this.delta[i] = this.error[i] * this.activationDerivative(this.z[i]);
            else
                this.delta[i] = this.error[i] * this.activationDerivative(this.output[i]);
        }
    }

    updateWB(learningRate) {
        for (let i = 0; i < this.numNeurons; i++) {
            for (let j = 0; j < this.numInputs; j++) {
                this.weights[i][j] -= learningRate * this.delta[i] * this.input[j];
            }
            this.biases[i] -= learningRate * this.delta[i];
        }
    }
}

class NeuralNetwork {
    constructor(layerSizes, learningRate, epochs) {
        this.numLayers = layerSizes.length - 1;
        this.layers = [];
        let i = 1;
        for (i; i < layerSizes.length - 1; i++) {
            this.layers.push(new Layer(layerSizes[i], layerSizes[i - 1], 'relu'));
        }
        this.layers.push(new Layer(layerSizes[i], layerSizes[i - 1]));

        this.learningRate = learningRate;
        this.epochs = epochs;

        this.totalError = 0.0;
    }

    forwardPass(inputArr) {
        let dataInput = inputArr;
        for (let i = 0; i < this.numLayers; i++) {
            dataInput = this.layers[i].forward(dataInput);
        }
        // at the last iteration dataInput accepts the
        // forward pass' final output generated by output layer
        return dataInput;
    }

    backwardPass(labelArr) {
        // find err for the last layer (-1)th
        let nextLayer = this.layers[this.numLayers - 1];
        // console.log(nextLayer);
        for (let i = 0; i < nextLayer.numNeurons; i++) {
            nextLayer.error[i] = nextLayer.output[i] - labelArr[i];
            nextLayer.delta[i] = nextLayer.error[i] * nextLayer.activationDerivative(nextLayer.output[i]);
            this.totalError += nextLayer.error[i] * nextLayer.error[i];
        }

        for (let i = this.numLayers - 2; i >= 0; i--) {
            const currLayer = this.layers[i];
            currLayer.backward(nextLayer);
            nextLayer = currLayer;
        }
    }

    updateWB() {
        for (let i = this.numLayers - 1; i >= 0; i--) {
            const currLayer = this.layers[i];
            currLayer.updateWB(this.learningRate);
        }
    }

    shuffleData(DATA, NUM_SAMPLES) {
        // randomize inputs for batch making
        // is optional but improves generalization (yes)
        function swap(arr1, arr2, i, rand) {
            [arr1[i], arr1[rand]] = [arr1[rand], arr1[i]];
            [arr2[i], arr2[rand]] = [arr2[rand], arr2[i]];
        }

        for (let i = 0; i < NUM_SAMPLES; i++) {
            const rand = parseInt(Math.random() * NUM_SAMPLES) % NUM_SAMPLES;
            swap(DATA.inputs, DATA.labels, i, rand);
        }
    }

    trainSGD(TRAINING_DATA) {
        const NUM_SAMPLES = Math.min(TRAINING_DATA.inputs.length, TRAINING_DATA.labels.length);
        for (let epoch = 0; epoch < this.epochs; epoch++) {
            // this.shuffleData(TRAINING_DATA, NUM_SAMPLES);
            for (let s = 0; s < NUM_SAMPLES; s++) {
                this.forwardPass(TRAINING_DATA.inputs[s]);
                this.backwardPass(TRAINING_DATA.labels[s]);
                this.updateWB();
            }
            // console.log(`| Epoch ${String(epoch).padStart(4, '0')} | Error: ${(this.totalError / NUM_SAMPLES).toFixed(3)} |`);
            // this.totalError = 0.0;

            if (epoch % 1000 == 0) {
                console.log(`| Epoch ${String(epoch).padStart(4, '0')} | Error: ${(this.totalError / NUM_SAMPLES).toFixed(3)} |`);
                this.learningRate *= 0.98; // decay LR per 1000 Epochs
            }
            this.totalError = 0.0;
        }
    }

    // accumulateWBbatch(inputArr, Ho, Hd, Od, batchGradients) {
    //     // --- Accumulate weights and biases ---
    //     for (let i = 0; i < this.NUM_OUTPUTS; i++) {
    //         for (let j = 0; j < this.NUM_HIDDEN; j++) {
    //             batchGradients.Wo[i][j] += Od[i] * Ho[j];
    //         }
    //     }
    //     for (let i = 0; i < this.NUM_OUTPUTS; i++) {
    //         batchGradients.Bo[i] += Od[i];
    //     }

    //     for (let i = 0; i < this.NUM_HIDDEN; i++) {
    //         for (let j = 0; j < this.NUM_INPUTS; j++) {
    //             batchGradients.Wh[i][j] += Hd[i] * inputArr[j];
    //         }
    //     }
    //     for (let i = 0; i < this.NUM_HIDDEN; i++) {
    //         batchGradients.Bh[i] += Hd[i];
    //     }
    //     // --- Accumulate weights and biases ---
    // }

    // updateWBbatch(batchGradients, batchLen) {
    //     // W -= (learning_rate / batchLen) * gradient_sum_W
    //     // B -= (learning_rate / batchLen) * gradient_sum_B
    //     // --- Update weights and biases ---
    //     for (let i = 0; i < this.NUM_OUTPUTS; i++) {
    //         for (let j = 0; j < this.NUM_HIDDEN; j++) {
    //             this.Wo[i][j] -= (this.LEARNING_RATE / batchLen) * batchGradients.Wo[i][j];
    //         }
    //         this.Bo[i] -= (this.LEARNING_RATE / batchLen) * batchGradients.Bo[i];
    //     }

    //     for (let i = 0; i < this.NUM_HIDDEN; i++) {
    //         for (let j = 0; j < this.NUM_INPUTS; j++) {
    //             this.Wh[i][j] -= (this.LEARNING_RATE / batchLen) * batchGradients.Wh[i][j];
    //         }
    //         this.Bh[i] -= (this.LEARNING_RATE / batchLen) * batchGradients.Bh[i];
    //     }
    //     // --- Update weights and biases ---
    // }

    // trainMBGD(TRAINING_DATA, BATCH_SIZE) {
    //     const NUM_SAMPLES = Math.min(TRAINING_DATA.inputs.length, TRAINING_DATA.labels.length);
    //     for (let epoch = 0; epoch < this.EPOCHS; epoch++) {
    //         this.shuffleData(TRAINING_DATA, NUM_SAMPLES);

    //         for (let batchStart = 0; batchStart < NUM_SAMPLES; batchStart += BATCH_SIZE) {
    //             const batchEnd = Math.min(batchStart + BATCH_SIZE, NUM_SAMPLES);
    //             // --- singular batch start ---
    //             let batchGradients = {
    //                 Wh: this.generateZeroMatrix(this.NUM_HIDDEN, this.NUM_INPUTS),
    //                 Bh: new Array(this.NUM_HIDDEN).fill(0),
    //                 Wo: this.generateZeroMatrix(this.NUM_OUTPUTS, this.NUM_HIDDEN),
    //                 Bo: new Array(this.NUM_OUTPUTS).fill(0)
    //             };

    //             for (let s = batchStart; s < batchEnd; s++) {
    //                 // --- singular input start ---
    //                 const Ho = new Array(this.NUM_HIDDEN).fill(0);
    //                 const He = new Array(this.NUM_HIDDEN).fill(0);
    //                 const Hd = new Array(this.NUM_HIDDEN).fill(0);

    //                 const Oo = new Array(this.NUM_OUTPUTS).fill(0);
    //                 const Oe = new Array(this.NUM_OUTPUTS).fill(0);
    //                 const Od = new Array(this.NUM_OUTPUTS).fill(0);

    //                 this.forwardPass(TRAINING_DATA.inputs[s], Ho, Oo);
    //                 this.backwardPass(TRAINING_DATA.labels[s], Ho, He, Hd, Oo, Oe, Od);
    //                 this.accumulateWBbatch(TRAINING_DATA.inputs[s], Ho, Hd, Od, batchGradients);
    //                 // --- singular input end ---
    //             }
    //             const batchLen = batchEnd - batchStart;
    //             // --- update batch gradients here ---
    //             this.updateWBbatch(batchGradients, batchLen);
    //             // --- update batch gradients here ---

    //             // --- singular batch end ---
    //             // batchStart += BATCH_SIZE;
    //             // batchEnd += BATCH_SIZE;
    //             // batchEnd = Math.min(batchEnd, NUM_SAMPLES);
    //         }

    //         console.log(`| Epoch ${String(epoch).padStart(4, '0')} | Error: ${(this.totalError / NUM_SAMPLES).toFixed(3)} |`);
    //         this.totalError = 0.0;

    //         // if (epoch % 1000 == 0) {
    //         //     console.log(`| Epoch ${String(epoch).padStart(4, '0')} | Error: ${(this.totalError / NUM_SAMPLES).toFixed(3)} |`);
    //         // }
    //         // this.totalError = 0.0;
    //     }
    // }

    predict(inputArr) {
        return this.forwardPass(inputArr);
    }

    softmax(x) {
        const maxX = Math.max(...x);
        const expValues = x.map(value => Math.exp(value - maxX));
        const sumExpValues = expValues.reduce((acc, curr) => acc + curr, 0);
        return expValues.map(value => value / sumExpValues);
    }

    dumpWB(savePath) {
        const filePath = savePath || path.join(__dirname, 'model.json');
        console.log("[debug]: savePath: ", filePath);
        fs.writeFile(filePath, JSON.stringify({
            layers: this.layers
        }), (err) => {
            if (err) throw err;
            console.log('The file has been saved!');
        });
    }

    async loadWB(savePath) {
        const filePath = savePath || path.join(__dirname, 'model.json');
        console.log("[debug]: savePath: ", filePath);

        try {
            const data = await fs.promises.readFile(filePath, 'utf8');
            const obj = JSON.parse(data);

            this.layers = [];
            obj.layers.forEach(layer => {
                // console.log(layer)
                const newLayer = new Layer(layer.numNeurons, layer.numInputs, layer.activation)
                newLayer.weights = layer.weights;
                newLayer.biases = layer.biases;

                this.layers.push(newLayer);
            });
        } catch (err) {
            console.error("Error loading the file:", err);
        }
    }
}

module.exports = NeuralNetwork;